//
//  MetaMetadataRepository.cs
//  s.im.pl serialization
//
//  Generated by DotNetTranslator on 11/16/10.
//  Copyright 2010 Interface Ecology Lab. 
//

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Reflection;
using Ecologylab.BigSemantics.Connectors;
using Ecologylab.BigSemantics.MetaMetadataNS.Net;
using Ecologylab.BigSemantics.MetaMetadataNS.Textformat;
using Ecologylab.BigSemantics.MetadataNS;
using Ecologylab.BigSemantics.MetadataNS.Builtins;
using Ecologylab.BigSemantics.MetadataNS.Scalar.Types;
using Ecologylab.BigSemantics.Namesandnums;
using Simpl.Fundamental.Collections;
using Simpl.Fundamental.Generic;
using Simpl.Fundamental.Net;
using Simpl.Fundamental.PlatformSpecifics;
using Simpl.Serialization.Attributes;
using Simpl.Serialization;
using Ecologylab.BigSemantics.MetadataNS.Scalar;
using System.Text.RegularExpressions;

namespace Ecologylab.BigSemantics.MetaMetadataNS 
{
    /// <summary>
    /// missing java doc comments or could not find the source file.
    /// </summary>
    public class MetaMetadataRepository : ElementState
    {
        public static bool stopTheConsoleDumping = false;

        #region Locals

        private static String FIREFOX_3_6_4_AGENT_STRING =
            "Mozilla/5.0 (Windows; U; Windows NT 6.1; ru; rv:1.9.2.4) Gecko/20100513 Firefox/3.6.4";

        private readonly Dictionary<String, MetaMetadata>
            _repositoryByClassName;

        /**
         * Repository with noAnchorNoQuery URL string as key.
         */

        private readonly Dictionary<String, MetaMetadata>
            _documentRepositoryByUrlStripped;

        /**
         * Repository with domain as key.
         */

        private readonly Dictionary<String, MetaMetadata>
            _documentRepositoryByDomain;

        /**
         * Repository for ClippableDocument and its subclasses.
         */

        private readonly Dictionary<String, MetaMetadata>
            _clippableDocumentRepositoryByUrlStripped;

        private readonly Dictionary<String, List<RepositoryPatternEntry>>
            _documentRepositoryByPattern;

        private readonly Dictionary<String, List<RepositoryPatternEntry>>
            _clippableDocumentRepositoryByPattern;

        /// <summary>
        /// missing java doc comments or could not find the source file.
        /// </summary>
        [SimplScalar] private String name;

        /// <summary>
        /// missing java doc comments or could not find the source file.
        /// </summary>
        [SimplTag("package")] [SimplScalar] private String packageName;

        /// <summary>
        /// missing java doc comments or could not find the source file.
        /// </summary>
        [SimplMap("user_agent")] private Dictionary<String, UserAgent> userAgents;

        /// <summary>
        /// missing java doc comments or could not find the source file.
        /// </summary>
        [SimplMap("search_engine")] private Dictionary<String, SearchEngine> searchEngines;

        /// <summary>
        /// missing java doc comments or could not find the source file.
        /// </summary>
        [SimplMap("named_style")] private Dictionary<String, NamedStyle> namedStyles;

        /// <summary>
        /// missing java doc comments or could not find the source file.
        /// </summary>
        [SimplScalar] private String defaultUserAgentName;

        /// <summary>
        /// missing java doc comments or could not find the source file.
        /// </summary>
        [SimplNoWrap] [SimplCollection("cookie_processing")] private List<CookieProcessing> cookieProcessors;

        /// <summary>
        /// The map from meta-metadata name (currently simple name, but might be extended to fully
        /// qualified name in the future) to meta-metadata objects. This collection is filled during the
        /// loading process.
        /// </summary>
        [SimplMap("meta_metadata")] [SimplNoWrap] private Dictionary<String, MetaMetadata> _repositoryByName;

        private Dictionary<String, MetaMetadata> _repositoryByMime = new Dictionary<string, MetaMetadata>();

        private Dictionary<String, MetaMetadata> _repositoryBySuffix = new Dictionary<string, MetaMetadata>();

        private Dictionary<string, MmdScope> packageMmdScopes;

        /// <summary>
        /// missing java doc comments or could not find the source file.
        /// </summary>
        [SimplMap("selector")] [SimplNoWrap] private Dictionary<String, MetaMetadataSelector> selectorsByName;

        /// <summary>
        /// missing java doc comments or could not find the source file.
        /// </summary>
        [SimplMap("site")] private Dictionary<String, SemanticsSite> sites;

        private String defaultUserAgentString = null;


        public SimplTypesScope MetadataTScope { get; set; }

        public string File { get; set; }

        private static bool initializedTypes;

        ///<summary>
        /// Collection of URL prefixes.
        ///</summary>
        private PrefixCollection<MetaMetadata> urlPrefixCollection = new PrefixCollection<MetaMetadata>('/');

        #endregion

        public MetaMetadataRepository()
        {
            _clippableDocumentRepositoryByPattern = new Dictionary<String, List<RepositoryPatternEntry>>();
            _documentRepositoryByPattern = new Dictionary<String, List<RepositoryPatternEntry>>();
            _clippableDocumentRepositoryByUrlStripped = new Dictionary<String, MetaMetadata>();
            _documentRepositoryByDomain = new Dictionary<String, MetaMetadata>();
            _documentRepositoryByUrlStripped = new Dictionary<String, MetaMetadata>();

            _repositoryByClassName = new Dictionary<String, MetaMetadata>();
            _repositoryByName = new Dictionary<string, MetaMetadata>();
            _repositoryBySuffix = new Dictionary<string, MetaMetadata>();
            _repositoryByMime = new Dictionary<string, MetaMetadata>();
        }

        /// <summary>
        /// 
        /// Recursively bind MetadataFieldDescriptors to all MetaMetadataFields. Perform other
        /// initialization.
        /// </summary>
        /// <param name="metadataTScope"></param>
        public void BindMetadataClassDescriptorsToMetaMetadata(SimplTypesScope metadataTScope)
        {
            this.MetadataTScope = metadataTScope;

            //TraverseAndInheritMetaMetadata();

            // global metadata classes
            // use another copy because we may modify the scope during the process
            List<MetaMetadata> mmds = new List<MetaMetadata>(_repositoryByName.Values);

            foreach (MetaMetadata mmd in mmds)
            {
                MetadataClassDescriptor mcd = mmd.BindMetadataClassDescriptor(metadataTScope);
                if (mcd == null)
                {
                    Debug.WriteLineIf(BigSemanticsSettings.DebugLevel > 5, "Cannot bind metadata class descriptor for " + mmd);
                    this.RepositoryByName.Remove(mmd.Name);
                }
            }

            // other initialization stuffs
            foreach (MetaMetadata mmd in RepositoryByName.Values)
            {
                AddToRepositoryByClassName(mmd);
                //mmd.setUpLinkWith(this); //Note Implement linking.
            }
            if (PackageMmdScopes != null)
            {
                foreach (MmdScope scope in this.PackageMmdScopes.Values)
                {
                    foreach (MetaMetadata mmd in scope.Values)
                    {
                        AddToRepositoryByClassName(mmd);
                        //mmd.setUpLinkWith(this); //Note Implement linking.
                    }
                }
            }

            InitializeLocationBasedMaps();
        }

        private void AddToRepositoryByClassName(MetaMetadata mmd)
        {
            if (mmd.ExtendsAttribute != null || mmd.IsNewMetadataClass())
            {
                MetadataClassDescriptor mcd = mmd.MetadataClassDescriptor;
			    if (mcd != null)
				    RepositoryByClassName.Put(mcd.DescribedClass.Name, mmd);

			    foreach (MetaMetadata localMmd in mmd.Scope.valuesOfType<MetaMetadata>())
			    {
				    AddToRepositoryByClassName(localMmd);
			    }
		    }
               
        }


        public void TraverseAndInheritMetaMetadata()
        {
            if (_repositoryByName != null && _repositoryByName.Count > 0)
            {
                // make another copy because we may modify the collection (e.g. for adding inline definitions)
                foreach (MetaMetadata metaMetadata in _repositoryByName.Values)
                {
                    metaMetadata.Repository = this;
                    metaMetadata.InheritMetaMetadata(null);
                }
            }
        }

        public static void InitializeTypes()
        {
            if (!initializedTypes)
            {
                MetadataScalarType.init();
                MetaMetadataTranslationScope.Get();
                MetadataBuiltinsTypesScope.Get();
                initializedTypes = true;
            }
        }

        private void InitializeDefaultUserAgent()
        {
            if (defaultUserAgentString == null)
            {
                this.defaultUserAgentString = FIREFOX_3_6_4_AGENT_STRING;
            }
        }

        /**
	     * Initializes HashMaps for MetaMetadata selectors by URL or pattern. Uses the ClippableDocument and Document
	     * base classes to ensure that maps are only filled with appropriate matching MetaMetadata.
	     */

        public void InitializeLocationBasedMaps()
        {
            foreach (MetaMetadata metaMetadata in _repositoryByName.Values)
            {
                // metaMetadata.inheritMetaMetadata(this);

                Type metadataClass = metaMetadata.GetMetadataClass(MetadataTScope);
                if (metadataClass == null)
                {
                    Debug.WriteLine("No metadata class found for metaMetadata: " + metaMetadata.Name);
                    continue;
                }

                Dictionary<String, MetaMetadata> repositoryByUrlStripped;
                Dictionary<String, List<RepositoryPatternEntry>> repositoryByPattern;

                if (typeof(ClippableDocument).GetTypeInfo().IsAssignableFrom(metadataClass.GetTypeInfo()))
                {
                    repositoryByUrlStripped = _clippableDocumentRepositoryByUrlStripped;
                    repositoryByPattern = _clippableDocumentRepositoryByPattern;
                }
                else if (typeof(Document).GetTypeInfo().IsAssignableFrom(metadataClass.GetTypeInfo()))
                {
                    repositoryByUrlStripped = _documentRepositoryByUrlStripped;
                    repositoryByPattern = _documentRepositoryByPattern;
                }
                else
                    continue;

                // We need to check if something is there already
                // if something is there, then we need to check to see if it has its cf pref set
                // if not, then if I am null then I win

                //MetaMetadataSelector selector = metaMetadata.Selectors[0];//Note: Needs to consider all selectors. 

                if (metaMetadata.Selectors == null || metaMetadata.Selectors.Count == 0)
                    continue;
                foreach (MetaMetadataSelector selector in metaMetadata.Selectors)
                {
                    ParsedUri strippedPURL = selector.UrlStripped;
                    if (strippedPURL != null)
                    {
                        MetaMetadata inMap = null;
                        repositoryByUrlStripped.TryGetValue(strippedPURL.Stripped, out inMap);
                        if (inMap == null)
                            repositoryByUrlStripped.Add(strippedPURL.Stripped, metaMetadata);
                        else
                            Debug.WriteLine("MetaMetadata already exists in repositoryByUrlStripped for purl\n\t: " +
                                              strippedPURL + " :: " + inMap.Name + " Ignoring MMD: " + metaMetadata.Name);
                        metaMetadata.MMSelectorType = MMSelectorType.LOCATION;
                    }
                    else
                    {
                        ParsedUri urlPathTree = selector.UrlPathTree;
                        if (urlPathTree != null)
                        {
                            PrefixPhrase<MetaMetadata> pp = urlPrefixCollection.Add(urlPathTree);
                            pp.MappedObject = metaMetadata;
                            metaMetadata.MMSelectorType = MMSelectorType.LOCATION;
                        }
                        else
                        {
                            // here, url_path_tree is handled through regex.
                            // use .pattern() for comparison
                            String domain = selector.Domain; //??
//                                            (selector.UrlPathTree != null ? selector.UrlPathTree.Domain : null);
                            if (domain != null)
                            {
                                Regex urlPattern = selector.UrlRegex; //??
//                                                   (selector.UrlPathTree == null
//                                                       ? null
//                                                        : new Regex(selector.UrlPathTree.ToString().Replace("*", "[^/]+")));
                                if (urlPattern != null)
                                {
                                    List<RepositoryPatternEntry> bucket;
                                    repositoryByPattern.TryGetValue(domain, out bucket);
                                    if (bucket == null)
                                    {
                                        bucket = new List<RepositoryPatternEntry>(2);
                                        repositoryByPattern.Add(domain, bucket);
                                    }
                                    bucket.Add(new RepositoryPatternEntry(urlPattern, metaMetadata));
                                    metaMetadata.MMSelectorType = MMSelectorType.LOCATION;
                                }
                                else
                                {
                                    // domain only -- no pattern
                                    //TODO: 'PUT' HIDES ERRORS. This is only so that we can identify them
                                    if (_documentRepositoryByDomain.ContainsKey(domain))
                                    {
                                        Debug.WriteLine(
                                            "-----\tError: Adding MMD({0}) for domain({1}), but this domain is already used for MMD({2})",
                                            metaMetadata, domain, _documentRepositoryByDomain[domain]);
                                    }
                                    else
                                    {
                                        _documentRepositoryByDomain.Add(domain, metaMetadata);
                                    }

                                    metaMetadata.MMSelectorType = MMSelectorType.DOMAIN;
                                }
                            }
                        }
                    }
                }
            }
        }


        /// <summary>
        /// This initalizes the map based on mime type and suffix.
        /// </summary>
        public void InitializeSuffixAndMimeDicts()
        {
            if (_repositoryByName == null)
                return;

            foreach (MetaMetadata metaMetadata in _repositoryByName.Values)
            {
                if (metaMetadata.Selectors == null || metaMetadata.Selectors.Count <= 0) continue;

                MetaMetadataSelector selector = metaMetadata.Selectors[0]; //Note: Needs to consider all selectors. 
                List<String> suffixes = selector.Suffixes;
                if (suffixes != null)
                {
                    foreach (String suffix in suffixes)
                    {
                        // FIXME-- Ask whether the suffix and mime should be
                        // inherited or not
                        if (!_repositoryBySuffix.ContainsKey(suffix))
                        {
                            _repositoryBySuffix.Add(suffix, metaMetadata);
                            metaMetadata.MMSelectorType = MMSelectorType.SUFFIX_OR_MIME;
                        }
                    }
                }

                List<String> mimeTypes = selector.MimeTypes;
                if (mimeTypes != null)
                {
                    foreach (String mimeType in mimeTypes)
                    {
                        // FIXME -- Ask whether the suffix and mime should be
                        // inherited or not
                        if (!_repositoryByMime.ContainsKey(mimeType))
                        {
                            _repositoryByMime.Add(mimeType, metaMetadata);
                            metaMetadata.MMSelectorType = MMSelectorType.SUFFIX_OR_MIME;
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Integrate the contents of otherRepository with this one.
        /// </summary>
        /// <param name="repository"></param>
        public void IntegrateRepository(MetaMetadataRepository repository)
        {
            // combine userAgents
            if (!MergeDictionaries(repository.userAgents, this.userAgents))
                this.userAgents = repository.userAgents;

            // combine searchEngines
            if (!MergeDictionaries(repository.searchEngines, this.searchEngines))
                this.searchEngines = repository.searchEngines;

            // combine namedStyles
            if (!MergeDictionaries(repository.namedStyles, this.namedStyles))
                this.namedStyles = repository.namedStyles;

            // combine sites
            if (!MergeDictionaries(repository.sites, this.sites))
                this.sites = repository.sites;

            if (!MergeDictionaries(repository._repositoryByMime, this._repositoryByMime))
                this._repositoryByMime = repository._repositoryByMime;

            if (!MergeDictionaries(repository._repositoryBySuffix, this._repositoryBySuffix))
                this._repositoryBySuffix = repository._repositoryBySuffix;

            Dictionary<String, MetaMetadata> otherRepositoryByTagName = repository._repositoryByName;
            //set metaMetadata to have the correct parent repository in ElementState
            if (otherRepositoryByTagName != null)
            {
                foreach (MetaMetadata mmd in otherRepositoryByTagName.Values)
                {
                    mmd.Parent = this;
                    if (mmd.PackageName == null)
                        mmd.PackageName = repository.packageName;
                }

                if (!MergeDictionaries(otherRepositoryByTagName, this._repositoryByName))
                    this._repositoryByName = otherRepositoryByTagName;
            }
            //MetadataTScope = repository.MetadataTScope;

        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="srcDict"></param>
        /// <param name="destDict"></param>
        /// <returns></returns>
        public bool MergeDictionaries<String, T>(Dictionary<String, T> srcDict, Dictionary<String, T> destDict)
            where T : ElementState
        {
            if (destDict == null)
                return false;

            if (srcDict != null)
                foreach (KeyValuePair<String, T> entry in srcDict)
                {
                    if (destDict.ContainsKey(entry.Key))
                        destDict.Remove(entry.Key); //By Default the new value will override the old one.
                    destDict.Add(entry.Key, entry.Value);
                }

            return true;
        }

        /// <summary>
        ///  Get MetaMetadata. First, try matching by url_base. If this fails, including if the attribute is
        ///  null, then try by url_prefix. If this fails, including if the attribute is null, then try by
        ///  url_pattern (regular expression).
        ///  <p/>
        /// If that lookup fails, then lookup by tag name, to acquire the default.
        /// </summary>
        /// <param name="uri"></param>
        /// <param name="tagName"></param>
        /// <returns></returns>
        public MetaMetadata GetDocumentMM(ParsedUri uri, String tagName = DocumentParserTagNames.DocumentTag)
        {
            MetaMetadata result = null;
            if (uri != null)
            {
                if (!uri.IsFile)
                {

                    //String noAnchorNoQueryPageString = uri.GetLeftPart(UriPartial.Path);
                    String noAnchorNoQueryPageString = FundamentalPlatformSpecifics.Get().GetUriLeftPart(uri);

                    _documentRepositoryByUrlStripped.TryGetValue(noAnchorNoQueryPageString, out result);

                    if (result == null)
                    {
                        //Check to see if the url prefix is actually a url-path tree.
                        //TODO: For url-path-tree cases, we should just generate a regex to handle those cases.
                        PrefixPhrase<MetaMetadata> matchingPrefix = urlPrefixCollection.getMatchingPrefix(uri);
                        if (matchingPrefix != null)
                        {
                            result = matchingPrefix.MappedObject;
                        }
                    }

                    if (result == null)
                    {
                        String domain = uri.Domain;
                        if (domain != null)
                        {
                            List<RepositoryPatternEntry> entries = null;
                            _documentRepositoryByPattern.TryGetValue(domain, out entries);

                            if (entries != null)
                            {
                                foreach (RepositoryPatternEntry entry in entries)
                                {
                                    Match matcher = entry.Pattern.Match(uri.ToString());
                                    if (matcher.Success)
                                    {
                                        result = entry.MetaMetadata;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }
                // be careful of the order! suffix before domain

                if (result == null)
                {
                    String suffix = uri.Suffix;

                    if (suffix != null)
                        result = GetMMBySuffix(suffix);
                }
                if (result == null)
                {
                    String domain = uri.Domain;
                    _documentRepositoryByDomain.TryGetValue(domain, out result);

                    if (result != null)
                        Debug.WriteLine("Matched by domain = " + domain + "\t" + result);
                }

            }
            if (result == null)
               result = GetMMByName(tagName);

            return result;
        }

        public MetaMetadata GetMMBySuffix(string suffix)
        {
            MetaMetadata result = null;
            _repositoryBySuffix.TryGetValue(suffix, out result);
            return result;

        }

        public MetaMetadata GetMMByMime(string mimeType)
        {
            MetaMetadata result = null;
            _repositoryByMime.TryGetValue(mimeType, out result);
            return result;
        }

        public MetaMetadata GetMMByName(String tagName)
        {
            if (tagName == null)
                return null;
            MetaMetadata result = null;
            _repositoryByName.TryGetValue(tagName, out result);
            return result;
        }

        public MetaMetadata GetByClass(Type metadataClass)
        {
            if (metadataClass == null)
                return null;

            MetaMetadata result = null;
            // String tag = metadataTScope.getTag(metadataClass);
            RepositoryByClassName.TryGetValue(metadataClass.Name, out result);
            return result;
        }

        public Document ConstructDocument(ParsedUri location, bool isImage)
        {
            // if (location.IsImage) return constructImage(location);
            if (isImage)
                return ConstructImage(location);
            MetaMetadata mmd = GetDocumentMM(location);
            Document result = mmd.ConstructMetadata(MetadataTScope) as Document;
            if (result != null)
                result.Location = new MetadataParsedURL(location);
            return result;
        }

        public Image ConstructImage(ParsedUri location)
        {
            MetaMetadata metaMetadata = GetImageMM(location);
		    Image result = null;
		    if (metaMetadata != null)
		    {
			    result = (Image) metaMetadata.ConstructMetadata(this.MetadataTScope);
			    result.Location = new MetadataParsedURL(location);
		    }
		    return result;
        }

        #region Properties

        public String Name
        {
            get { return name; }
            set { name = value; }
        }

        public String PackageName
        {
            get { return packageName; }
            set { packageName = value; }
        }

        public Dictionary<String, UserAgent> UserAgents
        {
            get
            {
                if (userAgents == null)
                    userAgents = new Dictionary<String, UserAgent>();
                return userAgents;
            }
            set { userAgents = value; }
        }

        public Dictionary<String, SearchEngine> SearchEngines
        {
            get { return searchEngines; }
            set { searchEngines = value; }
        }

        public Dictionary<String, NamedStyle> NamedStyles
        {
            get { return namedStyles; }
            set { namedStyles = value; }
        }

        public String DefaultUserAgentName
        {
            get { return defaultUserAgentName; }
            set { defaultUserAgentName = value; }
        }

        public String DefaultUserAgentString
        {
            get
            {
                if (DefaultUserAgentName == null)
                {
                    foreach (UserAgent userAgent in UserAgents.Values)
                    {
                        if (userAgent.DefaultAgent)
                        {
                            DefaultUserAgentName = userAgent.Name;
                            break;
                        }
                    }
                }
                return UserAgents[DefaultUserAgentName].UserAgentString;
            }
        }

        public List<CookieProcessing> CookieProcessors
        {
            get { return cookieProcessors; }
            set { cookieProcessors = value; }
        }

        public Dictionary<String, MetaMetadata> RepositoryByName
        {
            get { return _repositoryByName; }
            set { _repositoryByName = value; }
        }

        public Dictionary<String, MetaMetadataSelector> SelectorsByName
        {
            get { return selectorsByName; }
            set { selectorsByName = value; }
        }

        public Dictionary<String, SemanticsSite> Sites
        {
            get { return sites; }
            set { sites = value; }
        }

        public Dictionary<string, MmdScope> PackageMmdScopes
        {
            get { return packageMmdScopes; }
            set { packageMmdScopes = value; }
        }

        public Dictionary<string, MetaMetadata> RepositoryByClassName
        {
            get { return _repositoryByClassName; }
        }

        #endregion

        public MetaMetadata GetImageMM(ParsedUri location)
        {
            return GetDocumentMM(location);
        }
    }
}
